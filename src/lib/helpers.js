var l = require('./logger.js'),
	_ = require('lodash'),
	Q = require('q'),
	randtoken = require('rand-token'),	
    EventLogger = require('./environment-event-logger');

/**
 * Calculates the name of the S3 bucket to upload source bundle to. Bucket name
 * is read from deployment config, or if not set, is derived from the application
 * name
 * 
 * @param {object} config The deployment config
 * @return {string}
 */
module.exports.calculateBucketName = function(config) {
	return config.Bucket ? 
		   config.Bucket : 
		   config.ApplicationName.replace(/\s/g, '-').toLowerCase() + "-packages";
}

/**
 * Calculates a unique environment name, given a base name and suffix. The base
 * name is the common name used in the deployment configuration, such as "staging"
 * or "production", the suffix is one of "a" or "b". The name returned will include
 * a unique, random string.
 *
 * @param {string} name
 * @param {string} suffix
 * @return {string}
 */
module.exports.calculateEnvironmentName = function(name, suffix) {
	return [name, suffix, randtoken.generate(8)].join('-');
}

/**
 * Calculate the DNS cname prefix to use, given an application name, an environment
 * name, and whether the environment is "active"
 *
 * @param {string} applicationName
 * @param {string} environmentName
 * @param {bool} isActive
 * @return {String}
 */
module.exports.calculateCnamePrefix = function(applicationName, environmentName, isActive) {
	return [applicationName.replace(/\s/, '-').toLowerCase(), "-", environmentName, isActive ? "" : "-inactive"].join("");
}

/**
 * Retrives the suffix ("a" or "b") from an environment name. The environment name
 * is expected to have been generated by calculateEnvrionmentName()
 *
 * @param {string} name
 * @return {string}
 */
module.exports.getSuffixFromEnvironmentName = function(name) {
	var tokens = name.split('-');
	return tokens[tokens.length - 2];
}

/**
 * Calculates the version label to use, given a deployment config and user provided
 * options
 *
 * @param {object} config
 * @param {object} options
 * @return {string}
 */
module.exports.calculateVersionLabel = function(config, options) {
	// set version label to supplied value else a random token
	var versionLabel = (args.versionLabel)? args.versionLabel : randtoken.generate(16);
	// if a prefix is supplied prepend it to the version label
	return (args.versionPrefix)? args.versionPrefix+args.versionLabel : versionLabel
}

module.exports.genericRollback = function(fsm, data) {
    return function(err) {
        //l.error("ROLLBACK FROM %j", fsm.getCurrentState());
        //data.rollbackFromState = fsm.getCurrentState();
        data.error = err;
        fsm.doAction("rollback", data);
    }
}

module.exports.genericContinue = function(fsm, data) {
	return function() {
		fsm.doAction("next", data);
	}
}    

/**
 * Creates a normalized version of the application name usable in a URL or
 * as an ID etc..
 *
 * @param {string} applicationName
 * @return {string}
 * TODO: refactor to common lib
 */
module.exports.normalizeApplicationName = function(applicationName) {
	return applicationName.replace(/\s/, '-').toLowerCase();
}

/**
 * Waits for an Elastic Beanstalk environment to be ready. fnCompleteTest is a function
 * that takes the requested environment as its single argument and returns a boolean
 * indicating whether the environment is ready. Returns a promise for the specified
 * environment object that will be resolved once the environment passes fnCompleteTest
 *
 * @param {object} eb An Elastic Beanstalk client
 * @param {string} applicationName
 * @param {string} environmentName
 * @param {function} fnCompleteTest
 * @return {Promise}
 */
module.exports.waitForEnvironment = function(eb, applicationName, environmentName, fnCompleteTest) {

	l.info("Waiting for environment %s to be ready.", environmentName);

	var deferred = Q.defer();
		eventLogger = new EventLogger(eb, applicationName, environmentName, l.info);

	function checkStatus(applicationName, environmentName, deferred) {
		eb.describeEnvironments({
			ApplicationName : applicationName,
			EnvironmentNames : [environmentName]
		}, function(err, data) {
			if (err) {
				eventLogger.stop();
				deferred.reject(err);
			} else {
				var env = _.find(data.Environments, { EnvironmentName : environmentName });

				if (!env) {
					eventLogger.stop();
					deferred.reject({
						message : "Wait for environment failed. Could not locate environment " + environmentName
					});
				} else if (fnCompleteTest(env)) {
					eventLogger.stop();
					deferred.resolve(env);
				} else {
					_.delay(checkStatus, 1000, applicationName, environmentName, deferred);
				}
			}
		})
	}

	eventLogger.start();
	checkStatus(applicationName, environmentName, deferred);

	return deferred.promise;
}

